// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'page_one_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$PageOneStateTearOff {
  const _$PageOneStateTearOff();

  _Initial initial() {
    return const _Initial();
  }
}

/// @nodoc
const $PageOneState = _$PageOneStateTearOff();

/// @nodoc
mixin _$PageOneState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PageOneStateCopyWith<$Res> {
  factory $PageOneStateCopyWith(
          PageOneState value, $Res Function(PageOneState) then) =
      _$PageOneStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$PageOneStateCopyWithImpl<$Res> implements $PageOneStateCopyWith<$Res> {
  _$PageOneStateCopyWithImpl(this._value, this._then);

  final PageOneState _value;
  // ignore: unused_field
  final $Res Function(PageOneState) _then;
}

/// @nodoc
abstract class _$InitialCopyWith<$Res> {
  factory _$InitialCopyWith(_Initial value, $Res Function(_Initial) then) =
      __$InitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$InitialCopyWithImpl<$Res> extends _$PageOneStateCopyWithImpl<$Res>
    implements _$InitialCopyWith<$Res> {
  __$InitialCopyWithImpl(_Initial _value, $Res Function(_Initial) _then)
      : super(_value, (v) => _then(v as _Initial));

  @override
  _Initial get _value => super._value as _Initial;
}

/// @nodoc

class _$_Initial implements _Initial {
  const _$_Initial();

  @override
  String toString() {
    return 'PageOneState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Initial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements PageOneState {
  const factory _Initial() = _$_Initial;
}

/// @nodoc
class _$PageOneEventTearOff {
  const _$PageOneEventTearOff();

  NextClick nextClick() {
    return const NextClick();
  }

  OpenSnackbarClick openSnackbarClick() {
    return const OpenSnackbarClick();
  }
}

/// @nodoc
const $PageOneEvent = _$PageOneEventTearOff();

/// @nodoc
mixin _$PageOneEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() nextClick,
    required TResult Function() openSnackbarClick,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? nextClick,
    TResult Function()? openSnackbarClick,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nextClick,
    TResult Function()? openSnackbarClick,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NextClick value) nextClick,
    required TResult Function(OpenSnackbarClick value) openSnackbarClick,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NextClick value)? nextClick,
    TResult Function(OpenSnackbarClick value)? openSnackbarClick,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NextClick value)? nextClick,
    TResult Function(OpenSnackbarClick value)? openSnackbarClick,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PageOneEventCopyWith<$Res> {
  factory $PageOneEventCopyWith(
          PageOneEvent value, $Res Function(PageOneEvent) then) =
      _$PageOneEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$PageOneEventCopyWithImpl<$Res> implements $PageOneEventCopyWith<$Res> {
  _$PageOneEventCopyWithImpl(this._value, this._then);

  final PageOneEvent _value;
  // ignore: unused_field
  final $Res Function(PageOneEvent) _then;
}

/// @nodoc
abstract class $NextClickCopyWith<$Res> {
  factory $NextClickCopyWith(NextClick value, $Res Function(NextClick) then) =
      _$NextClickCopyWithImpl<$Res>;
}

/// @nodoc
class _$NextClickCopyWithImpl<$Res> extends _$PageOneEventCopyWithImpl<$Res>
    implements $NextClickCopyWith<$Res> {
  _$NextClickCopyWithImpl(NextClick _value, $Res Function(NextClick) _then)
      : super(_value, (v) => _then(v as NextClick));

  @override
  NextClick get _value => super._value as NextClick;
}

/// @nodoc

class _$NextClick implements NextClick {
  const _$NextClick();

  @override
  String toString() {
    return 'PageOneEvent.nextClick()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is NextClick);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() nextClick,
    required TResult Function() openSnackbarClick,
  }) {
    return nextClick();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? nextClick,
    TResult Function()? openSnackbarClick,
  }) {
    return nextClick?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nextClick,
    TResult Function()? openSnackbarClick,
    required TResult orElse(),
  }) {
    if (nextClick != null) {
      return nextClick();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NextClick value) nextClick,
    required TResult Function(OpenSnackbarClick value) openSnackbarClick,
  }) {
    return nextClick(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NextClick value)? nextClick,
    TResult Function(OpenSnackbarClick value)? openSnackbarClick,
  }) {
    return nextClick?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NextClick value)? nextClick,
    TResult Function(OpenSnackbarClick value)? openSnackbarClick,
    required TResult orElse(),
  }) {
    if (nextClick != null) {
      return nextClick(this);
    }
    return orElse();
  }
}

abstract class NextClick implements PageOneEvent {
  const factory NextClick() = _$NextClick;
}

/// @nodoc
abstract class $OpenSnackbarClickCopyWith<$Res> {
  factory $OpenSnackbarClickCopyWith(
          OpenSnackbarClick value, $Res Function(OpenSnackbarClick) then) =
      _$OpenSnackbarClickCopyWithImpl<$Res>;
}

/// @nodoc
class _$OpenSnackbarClickCopyWithImpl<$Res>
    extends _$PageOneEventCopyWithImpl<$Res>
    implements $OpenSnackbarClickCopyWith<$Res> {
  _$OpenSnackbarClickCopyWithImpl(
      OpenSnackbarClick _value, $Res Function(OpenSnackbarClick) _then)
      : super(_value, (v) => _then(v as OpenSnackbarClick));

  @override
  OpenSnackbarClick get _value => super._value as OpenSnackbarClick;
}

/// @nodoc

class _$OpenSnackbarClick implements OpenSnackbarClick {
  const _$OpenSnackbarClick();

  @override
  String toString() {
    return 'PageOneEvent.openSnackbarClick()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is OpenSnackbarClick);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() nextClick,
    required TResult Function() openSnackbarClick,
  }) {
    return openSnackbarClick();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? nextClick,
    TResult Function()? openSnackbarClick,
  }) {
    return openSnackbarClick?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nextClick,
    TResult Function()? openSnackbarClick,
    required TResult orElse(),
  }) {
    if (openSnackbarClick != null) {
      return openSnackbarClick();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NextClick value) nextClick,
    required TResult Function(OpenSnackbarClick value) openSnackbarClick,
  }) {
    return openSnackbarClick(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NextClick value)? nextClick,
    TResult Function(OpenSnackbarClick value)? openSnackbarClick,
  }) {
    return openSnackbarClick?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NextClick value)? nextClick,
    TResult Function(OpenSnackbarClick value)? openSnackbarClick,
    required TResult orElse(),
  }) {
    if (openSnackbarClick != null) {
      return openSnackbarClick(this);
    }
    return orElse();
  }
}

abstract class OpenSnackbarClick implements PageOneEvent {
  const factory OpenSnackbarClick() = _$OpenSnackbarClick;
}

/// @nodoc
class _$PageOneCommandTearOff {
  const _$PageOneCommandTearOff();

  _GoToNext goToNext() {
    return const _GoToNext();
  }

  _OpenSnackbar openSnackbar() {
    return const _OpenSnackbar();
  }
}

/// @nodoc
const $PageOneCommand = _$PageOneCommandTearOff();

/// @nodoc
mixin _$PageOneCommand {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() goToNext,
    required TResult Function() openSnackbar,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? goToNext,
    TResult Function()? openSnackbar,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? goToNext,
    TResult Function()? openSnackbar,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GoToNext value) goToNext,
    required TResult Function(_OpenSnackbar value) openSnackbar,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_GoToNext value)? goToNext,
    TResult Function(_OpenSnackbar value)? openSnackbar,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GoToNext value)? goToNext,
    TResult Function(_OpenSnackbar value)? openSnackbar,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PageOneCommandCopyWith<$Res> {
  factory $PageOneCommandCopyWith(
          PageOneCommand value, $Res Function(PageOneCommand) then) =
      _$PageOneCommandCopyWithImpl<$Res>;
}

/// @nodoc
class _$PageOneCommandCopyWithImpl<$Res>
    implements $PageOneCommandCopyWith<$Res> {
  _$PageOneCommandCopyWithImpl(this._value, this._then);

  final PageOneCommand _value;
  // ignore: unused_field
  final $Res Function(PageOneCommand) _then;
}

/// @nodoc
abstract class _$GoToNextCopyWith<$Res> {
  factory _$GoToNextCopyWith(_GoToNext value, $Res Function(_GoToNext) then) =
      __$GoToNextCopyWithImpl<$Res>;
}

/// @nodoc
class __$GoToNextCopyWithImpl<$Res> extends _$PageOneCommandCopyWithImpl<$Res>
    implements _$GoToNextCopyWith<$Res> {
  __$GoToNextCopyWithImpl(_GoToNext _value, $Res Function(_GoToNext) _then)
      : super(_value, (v) => _then(v as _GoToNext));

  @override
  _GoToNext get _value => super._value as _GoToNext;
}

/// @nodoc

class _$_GoToNext implements _GoToNext {
  const _$_GoToNext();

  @override
  String toString() {
    return 'PageOneCommand.goToNext()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _GoToNext);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() goToNext,
    required TResult Function() openSnackbar,
  }) {
    return goToNext();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? goToNext,
    TResult Function()? openSnackbar,
  }) {
    return goToNext?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? goToNext,
    TResult Function()? openSnackbar,
    required TResult orElse(),
  }) {
    if (goToNext != null) {
      return goToNext();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GoToNext value) goToNext,
    required TResult Function(_OpenSnackbar value) openSnackbar,
  }) {
    return goToNext(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_GoToNext value)? goToNext,
    TResult Function(_OpenSnackbar value)? openSnackbar,
  }) {
    return goToNext?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GoToNext value)? goToNext,
    TResult Function(_OpenSnackbar value)? openSnackbar,
    required TResult orElse(),
  }) {
    if (goToNext != null) {
      return goToNext(this);
    }
    return orElse();
  }
}

abstract class _GoToNext implements PageOneCommand {
  const factory _GoToNext() = _$_GoToNext;
}

/// @nodoc
abstract class _$OpenSnackbarCopyWith<$Res> {
  factory _$OpenSnackbarCopyWith(
          _OpenSnackbar value, $Res Function(_OpenSnackbar) then) =
      __$OpenSnackbarCopyWithImpl<$Res>;
}

/// @nodoc
class __$OpenSnackbarCopyWithImpl<$Res>
    extends _$PageOneCommandCopyWithImpl<$Res>
    implements _$OpenSnackbarCopyWith<$Res> {
  __$OpenSnackbarCopyWithImpl(
      _OpenSnackbar _value, $Res Function(_OpenSnackbar) _then)
      : super(_value, (v) => _then(v as _OpenSnackbar));

  @override
  _OpenSnackbar get _value => super._value as _OpenSnackbar;
}

/// @nodoc

class _$_OpenSnackbar implements _OpenSnackbar {
  const _$_OpenSnackbar();

  @override
  String toString() {
    return 'PageOneCommand.openSnackbar()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _OpenSnackbar);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() goToNext,
    required TResult Function() openSnackbar,
  }) {
    return openSnackbar();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? goToNext,
    TResult Function()? openSnackbar,
  }) {
    return openSnackbar?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? goToNext,
    TResult Function()? openSnackbar,
    required TResult orElse(),
  }) {
    if (openSnackbar != null) {
      return openSnackbar();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GoToNext value) goToNext,
    required TResult Function(_OpenSnackbar value) openSnackbar,
  }) {
    return openSnackbar(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_GoToNext value)? goToNext,
    TResult Function(_OpenSnackbar value)? openSnackbar,
  }) {
    return openSnackbar?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GoToNext value)? goToNext,
    TResult Function(_OpenSnackbar value)? openSnackbar,
    required TResult orElse(),
  }) {
    if (openSnackbar != null) {
      return openSnackbar(this);
    }
    return orElse();
  }
}

abstract class _OpenSnackbar implements PageOneCommand {
  const factory _OpenSnackbar() = _$_OpenSnackbar;
}
